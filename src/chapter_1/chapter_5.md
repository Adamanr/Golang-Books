# Slice, map и их особенности

В этом уроке мы познакомимся с двумя важными структурами данных в Go — **slice** и **map**. Оба инструмента широко используются в повседневной разработке и предоставляют гибкие возможности для работы с коллекциями данных.

### Slice: Срезы в Go

**Slice** — это динамическая структура данных, которая представляет собой часть (срез) массива. В отличие от массивов, срезы не фиксированы по размеру, и их можно увеличивать или уменьшать по мере необходимости.

#### Создание и использование Slice

Срезы можно создать разными способами:

1. **От массива**:
   ```go
   arr := [5]int{1, 2, 3, 4, 5}
   slice := arr[1:4] // Срез с элементами 2, 3, 4
   ```

2. **С помощью функции `make`**:
   ```go
   slice := make([]int, 3) // Создаем срез длиной 3 и нулевыми значениями
   ```

3. **Литералы срезов**:
   ```go
   slice := []int{1, 2, 3, 4, 5} // Создаем срез из пяти элементов
   ```

#### Работа с срезами

Срезы имеют следующие важные свойства:

- **Длина (len)**: Количество элементов в срезе.
- **Ёмкость (cap)**: Количество элементов, которые могут быть помещены в срез до необходимости расширения.

Пример работы с длиной и ёмкостью:
```go
slice := []int{1, 2, 3, 4, 5}
fmt.Println(len(slice)) // 5
fmt.Println(cap(slice)) // 5
```

Чтобы добавить элементы в срез, используется функция **`append`**:
```go
slice = append(slice, 6)
fmt.Println(slice) // [1, 2, 3, 4, 5, 6]
```

> Когда срез выходит за границы своей начальной ёмкости, Go автоматически расширяет его, удваивая ёмкость.

Чтобы удалить последний элемент из среза мы тоже используем **`append`**:

```go 
func main(){
   slice := []int{1,2,3,4}
   s := 2 // Мы хотим удалить 2 элемент
   slice = append(slice[:s], slice[s+1:]...)
   fmt.Println(slice) // [1, 2, 4]
}
```

#### Особенности Slice:

1. **Срезы ссылаются на тот же массив**: Срезы "под капотом" являются ссылками на массив. Это значит, что изменение среза может изменить исходный массив.
   ```go
   arr := [5]int{1, 2, 3, 4, 5}
   slice := arr[1:4]
   slice[0] = 10 // Изменим первый элемент среза
   fmt.Println(arr) // [1, 10, 3, 4, 5]
   ```

2. **Срезы могут быть нулевыми**: Если срез не был инициализирован, его значение — `nil`, и длина такого среза равна нулю.
   ```go
   var slice []int
   fmt.Println(slice == nil) // true
   ```

3. **Копирование срезов**: Для копирования элементов одного среза в другой можно использовать функцию **`copy`**.
   ```go
   slice1 := []int{1, 2, 3}
   slice2 := make([]int, len(slice1))
   copy(slice2, slice1)
   fmt.Println(slice2) // [1, 2, 3]
   ```
<br>

---

## Map: Отображения в Go

**Map** — это структура данных, которая представляет собой коллекцию пар "ключ-значение". Ключи должны быть уникальными, и каждое значение связано с определённым ключом.

#### Создание и использование Map

Создать карту можно несколькими способами:

1. **С помощью функции `make`**:
   ```go
   m := make(map[string]int) // Создаем карту с ключами типа string и значениями типа int
   ```

2. **Литерал карты**:
   ```go
   m := map[string]int{
       "apple":  2,
       "banana": 3,
   }
   ```

#### Работа с map

Карта работает с операциями добавления, обновления, удаления и поиска значений:

1. **Добавление и обновление значений**:
   ```go
   m := make(map[string]int)
   m["apple"] = 5 // Добавляем пару "ключ-значение"
   m["apple"] = 10 // Обновляем значение для ключа "apple"
   ```

2. **Получение значения по ключу**:
   ```go
   value := m["apple"]
   fmt.Println(value) // 10
   ```

3. **Проверка наличия ключа**:
   При получении значения по ключу можно также проверить, существует ли данный ключ в карте:
   ```go
   value, ok := m["banana"]
   if ok {
       fmt.Println("Ключ найден, значение:", value)
   } else {
       fmt.Println("Ключ не найден")
   }
   ```

4. **Удаление элемента**:
   Используйте функцию **`delete`**, чтобы удалить элемент из карты:
   ```go
   delete(m, "apple")
   fmt.Println(m) // Карта больше не содержит ключ "apple"
   ```

#### Особенности Map:

1. **Порядок элементов не гарантируется**: В **map** элементы не упорядочены, и при каждой итерации по карте порядок может отличаться.
   ```go
   m := map[string]int{"apple": 2, "banana": 3}
   for key, value := range m {
       fmt.Println(key, value)
   }
   ```

2. **Ключи могут быть только сравниваемыми типами**: Это означает, что такие типы как срезы нельзя использовать в качестве ключей, но строки, числа и даже структуры — можно. Разрешённые типы ключей: bool, int, float, string, pointer, channel, interface, struct (если все типы полей можно сравнить), массивы (если тип данных можно сравнить) т.е. типы которые поддерживают сравнение.

3. **Нулевые значения**: При попытке доступа к несуществующему ключу карта вернёт нулевое значение для типа данных (например, `0` для int, `""` для string).
   ```go
   m := make(map[string]int)
   fmt.Println(m["unknown"]) // 0
   ```

4. **Инициализация с нулевым значением**: Как и срезы, карты могут быть нулевыми (`nil`), если они не инициализированы.
   ```go
   var m map[string]int
   fmt.Println(m == nil) // true
   ```
   
## Фишки работы с map

### map[Type]struct{}

Указание struct{} в качестве значения для уменьшения объёма мапы. Например, если вам нужно сделать простую проверку, существует ли какое-то значение в мапе и для этого вы хотите создать мапу **`map[string]bool`**, то это не лучший вариант. В Go т.к. мы можем ставить ещё и структуры в мапу, то лучше было бы сделать такой пример **`map[string]struct{}`** т.к. пустая структура ничего не весит в отличии от типа bool.
```go 
aqua = make(map[string]struct{}, 0)
aqua["hello"] = struct{}{} 
```

### Map в алгоритмах

Использование типа map для различных алгоритмов. Т.к. по map поиск будет константный (Не учитываем коллизии), то данный тип часто используется для написания алгоритмов разной сложности. Например: 

**Two sum (LeetCode)** : Учитывая массив целых чисел nums и целое число target, нужно вернуть индексы двух чисел так, чтобы их сумма составляла target.  Вы можете попробовать сделать так, что каждый вход будет иметь ровно одно решение, и вы не можете использовать один и тот же элемент дважды.  Вы можете вернуть ответ в любом порядке.

Пример 1: <br>
input:  числа = [2,7,11,15] <br>
target = 9 <br>
output:  [0,1] <br>

***Объяснение:  Поскольку nums[0] + nums[1] == 9, мы возвращаем [0, 1]***

Пример 2: <br>
input: nums = [3,2,4] <br>
target = 6 <br>
output:  [1,2] <br>

Пример 3: <br>
input: nums = [3,3]
target = 6 <br>
output:  [0,1]


#### Решение
```go
func twoSum(nums []int, target int) []int {
    numMap := make(map[int]int)

    for k, num := range nums {
        comp := target - num 

        if field, ok := numMap[comp]; ok {
            return []int{k, field}
        }
        
        numMap[num] = k 
    }

    return []int{}
}

```

---

## Задания для работы со слайсами

### Задание 1: Увеличение слайса
Создайте функцию, которая принимает слайс чисел и добавляет к каждому элементу слайса число, равное его индексу. Функция должна возвращать новый слайс.

**Пример:**

```go
input := []int{1, 2, 3, 4}
output := AddIndexToElements(input) // Ожидается: [1, 3, 5, 7]
```

### Задание 2: Фильтрация слайса
Напишите функцию, которая принимает слайс строк и возвращает новый слайс, в который попадают только строки длиной больше 3 символов.

**Пример:**

```go
input := []string{"go", "slice", "map", "func"}
output := FilterLongStrings(input) // Ожидается: ["slice", "func"]
```

### Задание 3: Удаление элемента из слайса
Напишите функцию, которая удаляет элемент с определённым индексом из слайса целых чисел и возвращает новый слайс.

**Пример:**

```go
input := []int{10, 20, 30, 40, 50}
output := RemoveElement(input, 2) // Ожидается: [10, 20, 40, 50]
```

### Задание 4: Объединение слайсов
Напишите функцию, которая принимает два слайса и возвращает новый слайс, содержащий элементы обоих слайсов (конкатенация).

**Пример:**

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}
result := ConcatSlices(slice1, slice2) // Ожидается: [1, 2, 3, 4, 5, 6]
```


### Усложнённое задание: Сортировка слайса
Напишите программу, которая сортирует слайс целых чисел по возрастанию без использования встроенных функций сортировки (sort.Slice и т.п.).

## Задания для работы с мапами

### Задание 1: Подсчёт частоты элементов
Напишите функцию, которая принимает слайс строк и возвращает мапу, где ключами являются строки, а значениями — количество их повторений в слайсе.

**Пример:**

```go
input := []string{"apple", "banana", "apple", "orange", "banana", "apple"}
output := CountFrequencies(input) // Ожидается: {"apple": 3, "banana": 2, "orange": 1}
```

### Задание 2: Переворачивание мапы
Создайте функцию, которая принимает мапу вида `map[string]int` и возвращает новую мапу, где ключами являются значения исходной мапы, а значениями — ключи.

**Пример:**

```go
input := map[string]int{"one": 1, "two": 2, "three": 3}
output := ReverseMap(input) // Ожидается: {1: "one", 2: "two", 3: "three"}
```

### Задание 3: Объединение мап
Напишите функцию, которая объединяет два мапы `map[string]int`. Если ключи совпадают, их значения должны суммироваться.

**Пример:**

```go
map1 := map[string]int{"a": 1, "b": 2}
map2 := map[string]int{"b": 3, "c": 4}
result := MergeMaps(map1, map2) // Ожидается: {"a": 1, "b": 5, "c": 4}
```

### Задание 4: Поиск ключа по значению
Напишите функцию, которая принимает мапу и значение, и возвращает ключ, которому это значение соответствует. Если ключ не найден, возвращайте пустую строку.

**Пример:**

```go
input := map[string]int{"apple": 5, "banana": 10, "orange": 15}
key := FindKeyByValue(input, 10) // Ожидается: "banana"
```

### Задание 5: Удаление элементов
Напишите функцию, которая удаляет из мапы все элементы, чьи значения меньше определённого порога.

**Пример:**

```go
input := map[string]int{"a": 1, "b": 5, "c": 10, "d": 0}
output := RemoveLowValues(input, 3) // Ожидается: {"b": 5, "c": 10}
```


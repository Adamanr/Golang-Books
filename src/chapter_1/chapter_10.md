# Работа с паникой и defer

**Go** — это язык, который обеспечивает простой и понятный механизм обработки ошибок, а также предоставляет разработчикам контроль над обработкой исключительных ситуаций через использование **panic**, **recover**, и **defer**. Эти инструменты помогают грамотно управлять ошибками и обеспечивать корректное завершение программы.

### Что такое `panic`?

**`panic`** — это встроенная функция в Go, которая используется для создания исключительных ситуаций в программе. Когда вызывается `panic`, программа немедленно прекращает выполнение и начинает поиск функций для завершения (происходит **unwinding stack**, то есть разворачивание стека вызовов). Если функция **`recover`** не найдётся, программа завершится с ошибкой и сообщит об этом.

#### Когда использовать `panic`?

- В критических ситуациях, когда продолжение выполнения программы невозможно.
- Внутри пакетов и библиотек, где ошибка должна быть фатальной (например, критическая ошибка инициализации).

Пример использования `panic`:

```go
func divide(a, b int) int {
    if b == 0 {
        panic("Деление на ноль!")
    }
    return a / b
}

func main() {
    fmt.Println(divide(4, 2)) // Выведет 2
    fmt.Println(divide(4, 0)) // Вызовет панику: "Деление на ноль!"
}
```

### Что такое `defer`?

**`defer`** — это специальная конструкция в Go, которая позволяет отложить выполнение функции до того момента, когда текущая функция завершит выполнение (нормально или через панику). Это удобно для освобождения ресурсов, закрытия файлов, разблокировки мьютексов и т.д. А ещё defer выполнится после return

#### Пример использования `defer`:

```go
func main() {
    fmt.Println("Начало программы")
    
    defer fmt.Println("Эта строка выполнится в самом конце")
    
    fmt.Println("Завершение программы")
}
```

Результат выполнения программы:

```
Начало программы
Завершение программы
Эта строка выполнится в самом конце
```

### Что такое `recover`?

**`recover`** — это функция, которая используется внутри отложенной функции для восстановления программы после паники. `recover` позволяет поймать панику и продолжить выполнение программы, не завершив её аварийно.

#### Пример использования `recover`:

```go
func safeDivide(a, b int) {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Восстановлено после паники:", r)
        }
    }()
    
    fmt.Println("Результат:", a/b)
}

func main() {
    safeDivide(4, 2) // Выведет "Результат: 2"
    safeDivide(4, 0) // Выведет "Восстановлено после паники: Деление на ноль!"
}
```

В этом примере мы вызвали `recover` внутри отложенной функции. Это позволило нам поймать панику и продолжить выполнение программы.

### Порядок выполнения `defer`

Все отложенные вызовы с помощью `defer` выполняются в обратном порядке — от последнего к первому.

Пример:

```go
func main() {
    defer fmt.Println("Первый")
    defer fmt.Println("Второй")
    defer fmt.Println("Третий")
    
    fmt.Println("Программа завершается")
}
```

Результат выполнения:

```
Программа завершается
Третий
Второй
Первый
```

### Частые сценарии использования `defer`

1. **Закрытие файлов и освобождение ресурсов**:
   Использование `defer` удобно для закрытия файлов после их использования.

   ```go
   func readFile(filename string) {
       file, err := os.Open(filename)
       if err != nil {
           panic(err)
       }
       defer file.Close() // Файл автоматически закроется после завершения функции
       // Чтение файла
   }
   ```

2. **Откат транзакций**:
   В работе с транзакциями в базах данных `defer` помогает отменить или подтвердить транзакцию.

   ```go
   func executeTransaction() {
       tx := db.Begin()
       defer tx.Rollback() // Если произойдёт ошибка, транзакция откатится
       // Выполнение действий с транзакцией
       tx.Commit() // Если всё успешно, транзакция подтверждается
   }
   ```

### Задания для лучшего понимания

1. **Задание с паникой**:
   - Напишите функцию, которая делит два числа. Если делитель равен нулю, вызывайте панику с сообщением об ошибке. Обработайте панику с помощью `recover` и выведите сообщение об успешном восстановлении.

2. **Работа с `defer`**:
   - Создайте программу, которая открывает файл, читает из него данные и закрывает файл с помощью `defer`.
   - Дополните программу функцией, которая вызывает панику, если файл не удалось открыть, и восстанавливается с помощью `recover`.

3. **Использование `defer` для упорядочивания действий**:
   - Создайте функцию, которая выводит несколько строк текста с помощью нескольких операторов `defer`. Проверьте, в каком порядке они будут выполняться.

4. **Расширенное задание**:
   - Напишите функцию для работы с массивом чисел, которая удаляет элементы массива. В случае ошибки вызовите панику. Используйте `defer` для освобождения ресурсов и `recover` для продолжения работы программы после паники.

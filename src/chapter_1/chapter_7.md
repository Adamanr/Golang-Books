# Методы синхронизации между горутинами

Когда вы начинаете работать с несколькими горутинами, часто возникает необходимость синхронизации их работы. В Go для этого существует несколько мощных инструментов, таких как `sync.WaitGroup`, `sync.Mutex`, каналы, и другие примитивы синхронизации. Этот урок поможет вам понять, как эти механизмы работают и когда их стоит использовать.
## Темы урока:
- [sync.WaitGroup](#syncwaitgroup--Ожидание-завершения-горутин)
- [sync.Mutex](#syncmutex--Защита-данных-от-конкурентного-доступа)
- [sync.RWMutex](#syncrwmutex--Разделение-прав-на-чтение-и-запись)
- [Channel](#Каналы-для-синхронизации)
- [select](#Использование-select-с-небуферизированными-каналами)
- [sync.Map](#syncmap--Безопасная-карта-для-конкурентного-доступа)
- [sync.Cond](#synccond--Сложные-условия-для-синхронизации)

# **sync.WaitGroup** — Ожидание завершения горутин

`sync.WaitGroup` — это структура, которая помогает дождаться завершения нескольких горутин перед тем, как продолжить выполнение программы. Она содержит три основных метода:
- `Add(int)` — увеличивает счётчик горутин, которые нужно ожидать.
- `Done()` — уменьшает счётчик на единицу, указывая, что одна горутина завершила работу.
- `Wait()` — блокирует выполнение основной программы, пока счётчик не станет равен нулю.

**Пример использования:**

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done() // Уменьшает счётчик по завершению работы
    fmt.Printf("Worker %d начинает работу\n", id)
    time.Sleep(time.Second)
    fmt.Printf("Worker %d завершил работу\n", id)
}

func main() {
    var wg sync.WaitGroup
    for i := 1; i <= 5; i++ {
        wg.Add(1) // Увеличиваем счётчик для каждой горутины
        go worker(i, &wg)
    }

    wg.Wait() // Ждём завершения всех горутин
    fmt.Println("Все горутины завершены")
}
```

> **Когда использовать**: `sync.WaitGroup` полезен, когда нужно дождаться завершения нескольких горутин и продолжить выполнение программы.


# **sync.Mutex** — Защита данных от конкурентного доступа

`sync.Mutex` (mutual exclusion) используется для защиты общих данных, к которым одновременно обращаются несколько горутин. Это предотвращает "гонки данных", когда несколько горутин пытаются одновременно читать и изменять одни и те же переменные.

Методы `sync.Mutex`:
- `Lock()` — блокирует доступ к ресурсу.
- `Unlock()` — разблокирует доступ к ресурсу.

**Пример использования:**

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    mu.Lock()   // Блокируем доступ к переменной
    counter++   // Увеличиваем счётчик
    mu.Unlock() // Разблокируем доступ
}

func main() {
    var wg sync.WaitGroup

    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }

    wg.Wait()
    fmt.Printf("Итоговый счётчик: %d\n", counter)
}
```

> **Когда использовать**: `sync.Mutex` применяют, когда нужно защитить критические участки кода, которые работают с общими ресурсами (переменными, массивами, картами и т.д.).


# **sync.RWMutex** — Разделение прав на чтение и запись

`sync.RWMutex` (Read-Write Mutex) похож на обычный `Mutex`, но позволяет нескольким горутинам читать данные одновременно, пока никто не производит запись. Если требуется запись, доступ к переменной блокируется для всех горутин.

Основные методы:
- `RLock()` — блокирует для записи, но разрешает чтение.
- `RUnlock()` — разблокирует чтение.
- `Lock()` — блокирует для чтения и записи.
- `Unlock()` — разблокирует.

**Пример использования:**

```go
package main

import (
    "fmt"
    "sync"
)

var (
    data = make(map[string]string)
    mu   sync.RWMutex
)

func writeData(key, value string, wg *sync.WaitGroup) {
    defer wg.Done()
    mu.Lock() // Блокируем на запись
    data[key] = value
    mu.Unlock()
}

func readData(key string, wg *sync.WaitGroup) {
    defer wg.Done()
    mu.RLock() // Блокируем на чтение
    fmt.Println("Читаем значение:", data[key])
    mu.RUnlock()
}

func main() {
    var wg sync.WaitGroup

    wg.Add(1)
    go writeData("language", "Go", &wg)

    wg.Add(1)
    go readData("language", &wg)

    wg.Wait()
}
```

> **Когда использовать**: `sync.RWMutex` применяют, когда нужно разделить права доступа для чтения и записи, повышая производительность в ситуациях, где чтение доминирует над записью.


# **Каналы для синхронизации**

Каналы — это мощный инструмент в языке Go для организации взаимодействия между горутинами. Они позволяют безопасно передавать данные между потоками выполнения и реализовать концепцию коммуникации вместо явного использования блокировок.

Каналы создаются с помощью функции `make`, и могут быть **буферизированными** или **небуферизированными**:

```go
// Создание небуферизированного канала для передачи целых чисел
ch := make(chan int)

// Создание буферизированного канала с ёмкостью 2
chBuf := make(chan int, 2)
```

В небуферизированном канале операция отправки блокирует выполнение до тех пор, пока другая горутина не получит данные. Буферизированный канал позволяет отправлять несколько значений, пока не заполнится буфер.

### Основные операции с каналами

1. **Отправка данных в канал:**
   ```go
   ch <- 42  // Отправка значения 42 в канал
   ```

2. **Чтение данных из канала:**
   ```go
   value := <-ch  // Чтение значения из канала
   ```

3. **Закрытие канала:**
   Когда канал больше не будет использоваться для отправки данных, его следует закрыть, чтобы другие горутины знали, что данные больше не будут поступать.
   ```go
   close(ch)
   ```

   > После закрытия канала из него всё ещё можно читать данные, но попытка отправить в закрытый канал приведёт к панике.

## Буферизированные каналы

Буферизированные каналы позволяют отправлять несколько значений, не блокируя отправляющую горутину, пока буфер не заполнен. Получающая сторона будет блокироваться, только если буфер пуст.

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int, 2) // Буфер на 2 значения

    ch <- 1  // Можно отправить два значения без блокировки
    ch <- 2

    fmt.Println(<-ch)  // Чтение данных из канала
    fmt.Println(<-ch)
}
```

Здесь буферизированный канал позволяет отправить два значения подряд без блокировки, а затем получить их.

## Небуферезированные каналы

В отличие от буферизированных каналов, небуферизированные работают синхронно: отправка данных в такой канал блокирует горутину до тех пор, пока другая горутина не примет эти данные.


### Пример работы с небуферизированным каналом

Посмотрим на пример с двумя горутинами: одна отправляет данные через канал, а другая получает их.

```go
package main

import (
    "fmt"
)

func main() {
    ch := make(chan int)

    // Запускаем горутину для отправки данных
    go func() {
        fmt.Println("Отправляем данные в канал...")
        ch <- 42  // Отправляем значение 42
        fmt.Println("Данные отправлены")
    }()

    // Читаем данные из канала
    fmt.Println("Ожидаем данные...")
    value := <-ch
    fmt.Println("Получено значение:", value)
}
```

**Что здесь происходит:**
1. Мы создаём небуферизированный канал `ch`.
2. Запускаем горутину, которая отправляет данные в канал.
3. Основная горутина блокируется на чтении из канала до тех пор, пока данные не будут отправлены.
4. После этого обе горутины продолжают выполнение.

### Синхронизация через небуферизированные каналы

Каналы в Go используются не только для передачи данных, но и для синхронизации между горутинами. Небуферизированные каналы обеспечивают строгую синхронизацию, потому что отправка и получение должны происходить одновременно.

#### Пример синхронизации:

```go
package main

import (
    "fmt"
    "time"
)

func worker(done chan bool) {
    fmt.Println("Работа начинается...")
    time.Sleep(2 * time.Second) // Имитируем какую-то работу
    fmt.Println("Работа завершена")
    done <- true  // Сообщаем, что работа завершена
}

func main() {
    done := make(chan bool)

    go worker(done)

    // Ожидаем сигнал от горутины
    <-done
    fmt.Println("Главная горутина продолжает работу")
}
```

**Что происходит:**
1. Горутина `worker` выполняет свою работу и через 2 секунды отправляет сигнал в канал `done`, сообщая о завершении.
2. Главная горутина блокируется на операции чтения из канала до тех пор, пока горутина не завершит работу.


### Важные моменты при работе с небуферизированными каналами

1. **Ожидание обеих сторон:**
    - Если горутина пытается отправить данные в небуферизированный канал, но никто не ждёт этих данных, она заблокируется.
    - То же самое происходит при чтении: горутина блокируется, если данные ещё не были отправлены.

2. **Использование для строгой синхронизации:**
   Небуферизированные каналы обеспечивают строгую синхронизацию между двумя горутинами, что полезно, когда нужно чётко контролировать выполнение. Например, когда одна горутина должна завершиться до того, как другая продолжит работу.

3. **Потенциальные блокировки:**
   Небуферизированные каналы могут привести к блокировкам, если горутины не правильно организованы. Например, если горутина ожидает получения данных, а отправляющая горутина никогда не запускается, программа заблокируется навсегда.


### Пример с использованием нескольких горутин

В следующем примере несколько горутин отправляют значения в небуферизированный канал, а главная горутина считывает данные.

```go
package main

import (
    "fmt"
)

func sendValue(ch chan int, value int) {
    fmt.Printf("Отправляем %d в канал\n", value)
    ch <- value
    fmt.Printf("%d отправлен\n", value)
}

func main() {
    ch := make(chan int)

    // Запуск нескольких горутин для отправки данных
    go sendValue(ch, 1)
    go sendValue(ch, 2)
    go sendValue(ch, 3)

    // Получаем данные из канала
    fmt.Println("Получено:", <-ch)
    fmt.Println("Получено:", <-ch)
    fmt.Println("Получено:", <-ch)
}
```

В этом примере три горутины пытаются отправить данные в небуферизированный канал. Каждая из них будет заблокирована до тех пор, пока данные не будут прочитаны из канала в основной горутине.

# Использование `select` с небуферизированными каналами

Оператор `select` позволяет работать с несколькими каналами одновременно. Это полезно, когда нужно ожидать данные от разных горутин.

#### Пример с `select`:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    ch1 := make(chan string)
    ch2 := make(chan string)

    go func() {
        time.Sleep(1 * time.Second)
        ch1 <- "Сообщение из первого канала"
    }()

    go func() {
        time.Sleep(2 * time.Second)
        ch2 <- "Сообщение из второго канала"
    }()

    select {
    case msg1 := <-ch1:
        fmt.Println(msg1)
    case msg2 := <-ch2:
        fmt.Println(msg2)
    }
}
```

В этом примере `select` ждёт сообщения из двух каналов и обрабатывает первое поступившее сообщение.


# `sync.Map` — Безопасная карта для конкурентного доступа

Go предоставляет отличные инструменты для работы с картами, но обычные карты (map) не предназначены для безопасного использования в многопоточном окружении. Если несколько горутин пытаются одновременно читать и изменять карту, может произойти гонка данных. Для таких случаев Go предлагает `sync.Map`, которая обеспечивает безопасный доступ к карте в многопоточных программах.

`sync.Map` отличается от обычных карт:
- Не нужно использовать `sync.Mutex` для защиты операций с картой.
- Поддерживает безопасный конкурентный доступ для чтения, записи и удаления данных.
- Методы `sync.Map` оптимизированы для сценариев с большим количеством параллельных операций.

### Основные методы `sync.Map`

- **`Store(key, value interface{})`** — сохраняет значение по ключу.
- **`Load(key interface{}) (value interface{}, ok bool)`** — получает значение по ключу, если оно существует.
- **`LoadOrStore(key, value interface{}) (actual interface{}, loaded bool)`** — пытается получить значение по ключу. Если значение отсутствует, сохраняет новое.
- **`Delete(key interface{})`** — удаляет значение по ключу.
- **`Range(f func(key, value interface{}) bool)`** — перебирает все элементы карты и передаёт их в функцию обратного вызова. Если функция возвращает `false`, перебор останавливается.


### Пример использования `sync.Map`

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var m sync.Map

    // Запись значений в карту
    m.Store("language", "Go")
    m.Store("year", 2009)

    // Чтение значения
    value, ok := m.Load("language")
    if ok {
        fmt.Println("Значение ключа 'language':", value)
    }

    // Удаление значения
    m.Delete("year")

    // Попытка загрузки или сохранения
    actual, loaded := m.LoadOrStore("platform", "Linux")
    if loaded {
        fmt.Println("Ключ 'platform' уже существует со значением:", actual)
    } else {
        fmt.Println("Ключ 'platform' отсутствовал, добавлено значение:", actual)
    }

    // Перебор всех элементов
    m.Range(func(key, value interface{}) bool {
        fmt.Printf("Ключ: %v, Значение: %v\n", key, value)
        return true
    })
}
```

В данном примере:
- Мы добавляем несколько значений в карту с помощью метода `Store`.
- Читаем значения через `Load` и проверяем их существование.
- Используем метод `LoadOrStore` для проверки наличия ключа перед добавлением.
- Перебираем все элементы карты с помощью `Range`.

### Когда использовать `sync.Map`

`sync.Map` особенно полезна в ситуациях, когда:
- Часто выполняются конкурентные операции чтения и записи.
- Вы не хотите вручную защищать карту с помощью `sync.Mutex`.
- Требуется высокая производительность при частых операциях с данными в многопоточном окружении.

**Однако** `sync.Map` не всегда эффективнее, чем обычная карта с `sync.Mutex`. Если операции с картой редки или преимущественно записи, использование обычной карты с блокировками может быть быстрее.

### Пример сценария с `sync.Map` в горутинах

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var m sync.Map
    var wg sync.WaitGroup

    // Запуск нескольких горутин для записи данных
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            m.Store(fmt.Sprintf("key%d", id), id)
        }(i)
    }

    wg.Wait()

    // Перебор всех записей после завершения горутин
    m.Range(func(key, value interface{}) bool {
        fmt.Printf("Ключ: %v, Значение: %v\n", key, value)
        return true
    })
}
```

Здесь мы создаём несколько горутин, каждая из которых записывает уникальные ключи и значения в карту. После завершения всех горутин мы используем `Range`, чтобы вывести содержимое карты.

### Частые ошибки при работе с `sync.Map`

1. **Предположение о типе данных**: так как `sync.Map` работает с интерфейсами, вы всегда получаете значения типа `interface{}`. При чтении значений вам нужно использовать приведение типов, иначе может возникнуть паника.
   ```go
   value, ok := m.Load("key")
   intValue := value.(int) // Приведение типов
   ```

2. **Неиспользование `sync.Map` по назначению**: `sync.Map` оптимизирована для сценариев, где много горутин одновременно работают с картой. Если работа с картой однопоточная или требует большого количества операций записи, использование обычной карты с `sync.Mutex` может быть более подходящим.

3. **Использование сложных ключей**: так как ключи в `sync.Map` являются интерфейсами, убедитесь, что ключи могут корректно сравниваться, иначе могут возникнуть непредсказуемые результаты. Например, при использовании структур в качестве ключей важно реализовать правильные методы сравнения.

<br>


# sync.Cond — Сложные условия для синхронизации
sync.Cond — это условная переменная, позволяющая одной или нескольким горутинам ждать сигнала о том, что нужно продолжить выполнение. Она используется в случаях, когда несколько горутин должны дождаться определённого условия.

### Основные методы:
- Wait() — горутина ждёт сигнала.
- Signal() — сигнализирует одной горутине.
- Broadcast() — сигнализирует всем горутинам.

### Пример использования:
```go
package main

import (
   "fmt"
   "sync"
   "time"
)

var ready = false
var mu sync.Mutex
var cond = sync.NewCond(&mu)

func worker(id int, wg *sync.WaitGroup) {
   defer wg.Done()

    cond.L.Lock()
    for !ready {
        cond.Wait() // Ожидаем сигнала
    }
    fmt.Printf("Worker %d начал работу\n", id)
    cond.L.Unlock()
}

func main() {
   var wg sync.WaitGroup

    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }

    time.Sleep(time.Second)
    cond.L.Lock()
    ready = true
    cond.Broadcast() // Сигнализируем всем горутинам
    cond.L.Unlock()

    wg.Wait()
}
```

> Когда использовать: sync.Cond используется для синхронизации сложных зависимостей между горутинами, когда одна или несколько горутин должны ждать выполнения определённого условия.
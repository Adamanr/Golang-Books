# Горутины

Горутины — это одна из самых мощных и популярных функций в Go. Это лёгкие потоки, которые позволяют запускать функции параллельно (Параллели́зм — это свойство систем, при котором несколько вычислений выполняются одновременно, и при этом, возможно, взаимодействуют друг с другом), делая программы более эффективными и быстрыми. Основное преимущество горутин — их простота и низкая стоимость создания по сравнению с традиционными потоками в других языках программирования.

## Что такое горутина?

Горутина — это функция, которая выполняется параллельно с другими функциями в той же программе. Чтобы запустить функцию как горутину, достаточно перед её вызовом написать ключевое слово `go`.

### Пример запуска горутины:

```go
package main

import (
    "fmt"
    "time"
)

func printMessage(message string) {
    fmt.Println(message)
}

func main() {
    go printMessage("Привет от горутины!") // Запускаем функцию как горутину
    time.Sleep(1 * time.Second)            // Даем время для завершения горутины
    fmt.Println("Привет от main!")
}
```

В этом примере функция `printMessage` выполняется как горутина. Если бы мы не использовали `time.Sleep()`, то программа завершилась бы до того, как горутина успела бы выполнить своё задание.

### Особенности горутин:
1. **Лёгкость**: Создание горутин обходится значительно дешевле, чем создание системных потоков.
2. **Совместимость с каналами**: Для синхронизации между горутинами используются каналы, что позволяет безопасно передавать данные между ними.
3. **Автоматическое управление планированием**: Go-рантайм автоматически управляет планированием горутин на основе количества доступных системных потоков.

## Пример работы с несколькими горутинами

Давайте посмотрим, как можно запустить несколько горутин одновременно:

```go
package main

import (
    "fmt"
    "time"
)

func printNumber(number int) {
    fmt.Printf("Число: %d\n", number)
}

func main() {
    for i := 1; i <= 5; i++ {
        go printNumber(i) // Запуск горутин в цикле
    }
    time.Sleep(1 * time.Second) // Даём время для завершения всех горутин
}
```

В данном примере мы запускаем несколько горутин в цикле, каждая из которых печатает своё число. Опять же, `time.Sleep()` даёт возможность горутинам завершить выполнение перед завершением программы.

## Работа с анонимными горутинами

В Go также можно создавать анонимные функции, которые выполняются как горутины:

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    go func() {
        fmt.Println("Анонимная горутина")
    }()
    
    time.Sleep(1 * time.Second) // Ждем завершения анонимной горутины
}
```

Это полезно, когда вам нужно выполнить несложное действие параллельно, не создавая отдельную именованную функцию.

## Синхронизация горутин с помощью `WaitGroup`

Когда у нас несколько горутин, иногда нам нужно дождаться, пока все они завершат свою работу, прежде чем программа продолжит выполнение. Для этого используется структура `sync.WaitGroup`.

### Пример с использованием `WaitGroup`:

```go
package main

import (
    "fmt"
    "sync"
)

func printMessage(message string, wg *sync.WaitGroup) {
    defer wg.Done() // Сообщаем, что горутина завершила работу
    fmt.Println(message)
}

func main() {
    var wg sync.WaitGroup

    messages := []string{"Hello", "from", "multiple", "goroutines"}

    for _, msg := range messages {
        wg.Add(1) // Увеличиваем счётчик горутин
        go printMessage(msg, &wg)
    }

    wg.Wait() // Ожидаем завершения всех горутин
    fmt.Println("Все горутины завершены.")
}
```

В этом примере мы используем `sync.WaitGroup`, чтобы подождать, пока все горутины завершат выполнение. Каждая горутина сообщает о своём завершении с помощью метода `Done()`, а `wg.Wait()` блокирует выполнение основной функции до тех пор, пока все горутины не завершат работу.

## Общие ошибки при работе с горутинами

1. **Преждевременное завершение программы**: Основная программа может завершиться до того, как горутины успеют выполнить своё задание. Поэтому всегда важно правильно синхронизировать завершение горутин с помощью `WaitGroup` или других механизмов.

2. **Параллельный доступ к данным**: Если несколько горутин одновременно изменяют общие данные без синхронизации, это может привести к гонкам данных. Для избежания этого используйте каналы или `sync.Mutex`.

3. **Сложности с отладкой**: Ошибки, связанные с параллельным выполнением, иногда трудно отследить. Будьте внимательны при работе с горутинами и старайтесь минимизировать доступ к общим данным.

## Заключение

Горутины — это мощный инструмент для создания высокоэффективных и параллельных программ в Go. Они просты в использовании, но требуют внимательного подхода к синхронизации и управлению общими ресурсами. Теперь, когда вы знаете основы горутин, вы можете использовать их для ускорения ваших программ и эффективного решения задач, требующих параллелизма.

## Задания для практики

1. Напишите программу, которая запускает 10 горутин, каждая из которых печатает своё число. Убедитесь, что все горутины завершили выполнение перед завершением программы.

2. Модифицируйте программу так, чтобы горутины передавали свои результаты в основной поток через канал, и программа выводила результат по мере завершения каждой горутины.

3. Напишите программу, которая запускает несколько горутин для обработки элементов из списка, а затем собирает результаты в новый слайс.

### Дженерики в Go

Дженерики (Generics) — это одна из наиболее ожидаемых функций в языке Go, которая была официально представлена в версии **Go 1.18**. Дженерики позволяют писать более гибкий и повторно используемый код, благодаря возможности создавать функции и структуры данных, которые могут работать с разными типами данных, сохраняя при этом безопасность типов.

Ранее разработчики часто сталкивались с необходимостью дублирования кода для разных типов данных или использовали интерфейсы, что было менее эффективно. С введением дженериков эта проблема решена.

### Основные концепции дженериков

Основная идея дженериков заключается в том, что вы можете параметризировать функции и типы, передавая им параметры типов. Это позволяет одной функции или структуре работать с разными типами данных.

#### Объявление дженериков

Для создания дженерик-функции или типа используются **параметры типов**, которые заключаются в квадратные скобки `[]`.

#### Пример дженерик-функции:

```go
package main

import "fmt"

// Обобщенная функция для сложения двух элементов любого типа
func Add[T:any](a, b T) T {
    return a + b
}

func main() {
    fmt.Println(Add(3, 4))           // Работает с int
    fmt.Println(Add(3.5, 2.1))       // Работает с float64
}
```

Здесь:
- `T` — это параметр типа, который может быть любым типом, но не выведет панику только если тип будет иметь возможность складываться

### Ограничения на типы (Type Constraints)

Параметры типов могут быть ограничены для использования только определённых типов. Для этого используется **Type Constraints** (ограничения на типы).

#### Пример с ограничениями:

```go
package main

import "fmt"

// Ограничиваем типы для функции до числовых типов
func Multiply[T int | float64](a, b T) T {
    return a * b
}

func main() {
    fmt.Println(Multiply(3, 4))          // int
    fmt.Println(Multiply(3.5, 2.5))      // float64
}
```

В данном примере параметр типа `T` ограничен значениями `int` и `float64`, то есть функция `Multiply` может работать только с этими типами.

### Дженерики в структурах

Дженерики также могут быть использованы в структурах для создания универсальных структур данных.

#### Пример:

```go
package main

import "fmt"

// Универсальная структура для хранения любых данных
type Box[T any] struct {
    value T
}

func (b Box[T]) GetValue() T {
    return b.value
}

func main() {
    intBox := Box[int]{value: 42}
    fmt.Println(intBox.GetValue()) // Выводит 42

    stringBox := Box[string]{value: "Привет"}
    fmt.Println(stringBox.GetValue()) // Выводит "Привет"
}
```

- В этом примере структура `Box` может хранить данные любого типа, который передан через параметр типа `T`.

### Применение дженериков с интерфейсами

Go поддерживает использование дженериков вместе с интерфейсами для создания ещё более гибких решений.

#### Пример:

```go
package main

import "fmt"

// Интерфейс, ограничивающий типы до чего-то, что поддерживает операцию сложения
type Summable interface {
    int | float64
}

// Обобщённая функция сложения
func Sum[T Summable](a, b T) T {
    return a + b
}

func main() {
    fmt.Println(Sum(10, 20))       // Работает с int
    fmt.Println(Sum(5.5, 2.3))     // Работает с float64
}
```

- В данном примере используется интерфейс **Summable**, который ограничивает типы до `int` и `float64`.

### Полезные задания

1. **Задание на базовые дженерики:**
   Напишите функцию, которая принимает два параметра любого типа и возвращает их в обратном порядке.

2. **Задание с ограничениями типов:**
   Реализуйте функцию, которая принимает слайс чисел (`int` или `float64`) и возвращает их сумму.

3. **Задание на структуры с дженериками:**
   Создайте структуру с дженериками для хранения пары значений разного типа (например, `string` и `int`). Реализуйте методы для установки и получения этих значений.

4. **Задание на интерфейсы с дженериками:**
   Реализуйте интерфейс, который ограничивает типы до тех, которые поддерживают операцию сравнения. Затем создайте функцию для поиска минимального элемента в слайсе.

5. **Задание на вложенные дженерики:**
   Напишите функцию, которая принимает два слайса любого типа и возвращает слайс, содержащий все элементы первого и второго слайсов.



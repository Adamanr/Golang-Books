<!DOCTYPE HTML>
<html lang="ru" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Slice, map глубже - Курс по Golang</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../intro.html"><strong aria-hidden="true">1.</strong> О курсе</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_1.html"><strong aria-hidden="true">2.</strong> Основы Go</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_1/chapter_2.html"><strong aria-hidden="true">2.1.</strong> Первое знакомство с Go</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_3.html"><strong aria-hidden="true">2.2.</strong> Работа с переменными</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_4.html"><strong aria-hidden="true">2.3.</strong> Основные конструкции управления в Go</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_5.html"><strong aria-hidden="true">2.4.</strong> Slice, map и их особенности</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_6.html"><strong aria-hidden="true">2.5.</strong> Горутины</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_7.html"><strong aria-hidden="true">2.6.</strong> Методы синхронизации между горутинами</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_8.html"><strong aria-hidden="true">2.7.</strong> Интерфейсы</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_9.html"><strong aria-hidden="true">2.8.</strong> Структуры, интерфейсы и реверсивные методы</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_10.html"><strong aria-hidden="true">2.9.</strong> Работа с паникой и defer</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_11.html"><strong aria-hidden="true">2.10.</strong> Работа с файловой системой</a></li><li class="chapter-item expanded "><a href="../chapter_1/chapter_12.html"><strong aria-hidden="true">2.11.</strong> Generics</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_0.html"><strong aria-hidden="true">3.</strong> Погружение в глубину</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../chapter_2/chapter_1.html"><strong aria-hidden="true">3.1.</strong> Интерфейсы, рефлексия и type switch</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_2.html" class="active"><strong aria-hidden="true">3.2.</strong> Slice, map глубже</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_3.html"><strong aria-hidden="true">3.3.</strong> Горутины, sync.Cord и Worker Pool</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_4.html"><strong aria-hidden="true">3.4.</strong> Scheduler и уникальность горутин</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_5.html"><strong aria-hidden="true">3.5.</strong> Небезопасный Go</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_6.html"><strong aria-hidden="true">3.6.</strong> Системное программирование в Go и сигналы</a></li><li class="chapter-item expanded "><a href="../chapter_2/chapter_7.html"><strong aria-hidden="true">3.7.</strong> GC и методы работы с ним</a></li></ol></li><li class="chapter-item expanded "><a href="../chapter_3/chapter_3.html"><strong aria-hidden="true">4.</strong> Библиотеки Go</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Курс по Golang</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="slice-map-глубже"><a class="header" href="#slice-map-глубже">Slice, map глубже</a></h1>
<p>Давайте углубимся в темы <strong>slice</strong> и <strong>map</strong> в Go, чтобы лучше понять их работу, внутренние механизмы и применимость в реальных проектах.</p>
<h1 id="Углубляемся-в-slice"><a class="header" href="#Углубляемся-в-slice">Углубляемся в Slice</a></h1>
<h4 id="Внутреннее-устройство-slice"><a class="header" href="#Внутреннее-устройство-slice">Внутреннее устройство Slice</a></h4>
<p>Под капотом <strong>slice</strong> хранит три значения:</p>
<ol>
<li><strong>Указатель на базовый массив</strong>: Срез не хранит данные напрямую, а лишь содержит указатель на базовый массив, который фактически хранит элементы.</li>
<li><strong>Длина (len)</strong>: Количество элементов в срезе.</li>
<li><strong>Ёмкость (cap)</strong>: Количество элементов, которое может хранить базовый массив, начиная с первого элемента среза. Ёмкость всегда больше или равна длине.</li>
</ol>
<pre><code class="language-go">struct {
	array *[]T
	length int
	capacity int
}
</code></pre>
<p>Пример:</p>
<pre><code class="language-go">arr := [5]int{1, 2, 3, 4, 5}
slice := arr[1:4] // slice: [2, 3, 4], len(slice) = 3, cap(slice) = 4
</code></pre>
<p>В этом примере срез начинается с индекса 1 массива <code>arr</code>, поэтому он может "видеть" оставшиеся 4 элемента массива. Однако длина среза — это только 3 элемента: <code>[2, 3, 4]</code>.</p>
<h4 id="Расширение-slice"><a class="header" href="#Расширение-slice">Расширение Slice</a></h4>
<p>Когда вы добавляете элементы в срез с помощью функции <strong><code>append</code></strong>, Go автоматически создаёт новый базовый массив, если текущая ёмкость недостаточна. Этот новый массив будет вдвое больше старого, что позволяет улучшить производительность при многократном добавлении элементов.</p>
<p>Пример:</p>
<pre><code class="language-go">slice := []int{1, 2, 3}
slice = append(slice, 4, 5, 6)
fmt.Println(slice) // [1, 2, 3, 4, 5, 6]
</code></pre>
<p>Если исходная ёмкость была меньше 6, Go создаст новый массив и скопирует туда старые элементы.</p>
<h4 id="Работа-со-срезами"><a class="header" href="#Работа-со-срезами">Работа со срезами</a></h4>
<p>Важно понимать, что срезы могут <strong>делить один и тот же базовый массив</strong>. Это может привести к неожиданным результатам, если вы будете изменять один срез, а изменения отразятся на другом.</p>
<p>Пример:</p>
<pre><code class="language-go">arr := [5]int{1, 2, 3, 4, 5}
slice1 := arr[1:4] // slice1: [2, 3, 4]
slice2 := arr[2:5] // slice2: [3, 4, 5]
slice1[1] = 10     // Изменяем slice1
fmt.Println(arr)    // [1, 2, 10, 4, 5] - изменился массив
fmt.Println(slice2) // [10, 4, 5] - изменился и slice2
</code></pre>
<p>Чтобы избежать таких эффектов, можно копировать данные в новый срез с помощью функции <strong><code>copy</code></strong>.</p>
<h4 id="zero-value-slice"><a class="header" href="#zero-value-slice">Zero value Slice</a></h4>
<p>Нулевой срез имеет значение <code>nil</code>, но с ним можно работать, как с обычным срезом — добавлять элементы, получать длину и т.д. Это упрощает инициализацию срезов и избавляет от необходимости явного создания пустых срезов.</p>
<pre><code class="language-go">var slice []int
fmt.Println(slice == nil) // true
slice = append(slice, 1)
fmt.Println(slice) // [1]
</code></pre>
<h2 id="Особенность-slice-при-передаче"><a class="header" href="#Особенность-slice-при-передаче">Особенность slice при передаче</a></h2>
<p>Когда вы будете активно работать со слайсами, может возникнуть ситуация, которую можно назвать <strong>"Заблуждение указателей слайса"</strong> (условное название). Часто разработчики ошибочно полагают, что слайсы ведут себя как указатели, и любые изменения, такие как добавление элементов через <strong><code>append</code></strong>, будут видны после возврата из функции. Однако, это не совсем так.</p>
<p>Рассмотрим пример:</p>
<pre><code class="language-go">func main() {
    aqua := make([]int, 0, 2)
    appendSlice(aqua)
    fmt.Println(aqua) // Ожидаем [1], но будет []
}

func appendSlice(aqua []int) {
    aqua = append(aqua, 1)
}
</code></pre>
<p>В этом коде мы создаём слайс <code>aqua</code> и передаём его в функцию <strong><code>appendSlice</code></strong>, которая должна была добавить в него элемент. Однако, когда мы печатаем <code>aqua</code> в <code>main</code>, результат остаётся пустым.</p>
<h3 id="Почему-это-происходит"><a class="header" href="#Почему-это-происходит">Почему это происходит?</a></h3>
<p>Хотя слайс и содержит указатель на базовый массив, важно помнить, что сам слайс (структура, содержащая указатель, длину и ёмкость) передаётся в функцию <strong>по значению</strong>. Это означает, что в функции <strong><code>appendSlice</code></strong> мы работаем с копией слайса. Изменения, сделанные в этой копии, не отражаются на оригинальной переменной <code>aqua</code> в <code>main</code>.</p>
<p>В данном случае функция <strong><code>append</code></strong> может вернуть новый слайс, если при добавлении элементов ёмкости исходного базового массива не хватает. Поскольку в функции используется копия слайса, эти изменения не затрагивают исходный слайс в <code>main</code>.</p>
<h3 id="Как-это-исправить"><a class="header" href="#Как-это-исправить">Как это исправить?</a></h3>
<p>Чтобы изменения в слайсе были видны вне функции, нужно передать слайс <strong>по указателю</strong>. Это позволит функции работать с оригинальной структурой слайса:</p>
<pre><code class="language-go">func main() {
    aqua := make([]int, 0, 2)
    appendSlice(&amp;aqua)
    fmt.Println(aqua) // Теперь будет [1]
}

func appendSlice(aqua *[]int) {
    *aqua = append(*aqua, 1)
}
</code></pre>
<p>Теперь мы передаём указатель на слайс, и функция изменяет оригинальный слайс, добавляя в него элемент. Это работает, потому что теперь мы модифицируем саму структуру слайса через указатель, а не его копию.</p>
<blockquote>
<p>Хотя слайс содержит указатель на базовый массив, сама структура слайса передаётся <strong>по значению</strong>. Чтобы изменения были видны вне функции, необходимо передавать слайс по указателю.</p>
</blockquote>
<br>
<hr />
<h1 id="Углубляемся-в-map"><a class="header" href="#Углубляемся-в-map">Углубляемся в Map</a></h1>
<h4 id="Внутреннее-устройство-map"><a class="header" href="#Внутреннее-устройство-map">Внутреннее устройство Map</a></h4>
<p>Карта в Go представляет собой хеш-таблицу. Для каждого ключа вычисляется хеш, и на основе этого хеша определяется, в какое "ведро" (bucket) поместить этот ключ. Если несколько ключей имеют одинаковый хеш, они помещаются в одно ведро (так называемые <strong>коллизии</strong>), и внутри этого ведра Go использует линейный поиск для нахождения нужного ключа.</p>
<p>Эффективность карты основана на том, что поиск по хеш-таблице обычно выполняется за <strong>O(1)</strong> — константное время, хотя в случае коллизий время может увеличиться (Примерно будет <strong>O(N)</strong>).</p>
<pre><code class="language-go">type hmap struct {
  // ...more code
  count       int
  B           uint 8
  noverflow   uint 16
  hash0       uint 32
  buckets     unsafe.Pointer
  oldbuckets  unsafe.Pointer
}
</code></pre>
<h4 id="Инициализация-карты"><a class="header" href="#Инициализация-карты">Инициализация карты</a></h4>
<p>Часто карты инициализируются с помощью функции <strong><code>make</code></strong>, которая позволяет задать начальный размер карты. Если известно, что карта будет содержать много элементов, задание размера может улучшить производительность, так как это позволяет избежать перерасчёта и перераспределения хеш-таблицы.</p>
<p>Пример:</p>
<pre><code class="language-go">m := make(map[string]int, 100) // Создаём карту с начальной ёмкостью на 100 элементов
</code></pre>
<h4 id="Удаление-элементов-из-карты"><a class="header" href="#Удаление-элементов-из-карты">Удаление элементов из карты</a></h4>
<p>Для удаления элементов используется функция <strong><code>delete</code></strong>. Если ключ отсутствует в карте, то ничего страшного не произойдёт — ошибка не будет вызвана.</p>
<pre><code class="language-go">delete(m, "apple") // Удалим элемент с ключом "apple"
</code></pre>
<h4 id="Обход-элементов-карты"><a class="header" href="#Обход-элементов-карты">Обход элементов карты</a></h4>
<p>При использовании цикла <strong><code>for range</code></strong> порядок обхода элементов карты не гарантируется. Он будет случайным, и при каждом запуске программы может быть разным.</p>
<pre><code class="language-go">m := map[string]int{"apple": 1, "banana": 2}
for key, value := range m {
    fmt.Println(key, value)
}
</code></pre>
<p>Если вам требуется упорядоченный обход, нужно вручную сортировать ключи.</p>
<p>Пример сортировки ключей карты:</p>
<pre><code class="language-go">keys := make([]string, 0, len(m))
for key := range m {
    keys = append(keys, key)
}
sort.Strings(keys) // Сортируем ключи
for _, key := range keys {
    fmt.Println(key, m[key])
}
</code></pre>
<h4 id="Карты-как-нулевые-значения"><a class="header" href="#Карты-как-нулевые-значения">Карты как нулевые значения</a></h4>
<p>Карта, как и срезы, может иметь значение <strong><code>nil</code></strong>. Это полезно для обработки отсутствия значений, но попытка добавления элементов в <strong>nil map</strong> приведёт к панике.</p>
<pre><code class="language-go">var m map[string]int
fmt.Println(m == nil) // true
// m["apple"] = 5 // Это вызовет панику!
</code></pre>
<p>Чтобы избежать этого, всегда нужно инициализировать карту перед использованием.</p>
<h4 id="Ограничения-ключей-и-значений"><a class="header" href="#Ограничения-ключей-и-значений">Ограничения ключей и значений</a></h4>
<p>Ключи в картах должны быть <strong>сравнимыми типами</strong>, то есть типами, для которых возможны операции сравнения (<code>==</code>, <code>!=</code>). Это означает, что <strong>срезы</strong> и <strong>функции</strong> не могут быть ключами карты, так как они не сравнимы. Однако строки, числа, структуры и даже интерфейсы могут быть ключами.</p>
<p>Работа с мапами (карта) в Go может быть весьма удобной, однако существуют несколько особенностей, на которые стоит обратить внимание, чтобы избежать распространённых ошибок. В этой статье мы рассмотрим основные аспекты работы с мапами и их эвакуацию.</p>
<h2 id="Эвакуация-данных-в-мапах"><a class="header" href="#Эвакуация-данных-в-мапах">Эвакуация данных в мапах</a></h2>
<p>Эвакуация - это процесс когда map переносит свои значения из одной области памяти в другую. Это происходит из-за того что число значений в каждом отдельном bucket максимально равно 8.</p>
<p>В тот момент времени, когда среднее количество значений в bucket составляет 6.5, go понимает, что размер map не удовлетворяет необходимому. Начинается процесс расширения map.</p>
<p>Следует отметить, что сам процесс эвакуации может происходить некоторое время, на протяжение которого новые и старые данные будут связаны.</p>
<h2 id="Заключение"><a class="header" href="#Заключение">Заключение</a></h2>
<p>Работа с мапами в Go предоставляет множество возможностей для удобного хранения и извлечения данных. Однако, как и с любой другой структурой данных, важно знать основные правила и избежать распространённых ошибок. Зная о таких моментах, как эвакуация данных, проверка наличия ключей и правильная инициализация мап, вы сможете эффективно использовать эту мощную структуру данных в своих проектах.</p>
<br>
<hr />
<h1 id="Дополнительные-материалы"><a class="header" href="#Дополнительные-материалы">Дополнительные материалы</a></h1>
<ul>
<li><a href="https://habr.com/ru/companies/avito/articles/774618/">Мапы в Go: Уровень Pro</a></li>
<li><a href="https://www.youtube.com/watch?v=P_SXTUiA-9Y&amp;t=1222s">Как на самом деле работает тип Map в Go</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter_2/chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter_2/chapter_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter_2/chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter_2/chapter_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
